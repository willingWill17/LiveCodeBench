{"question_id": "abc365_e", "question_title": "Xor Sigma Problem", "question_content": "You are given an integer sequence A=(A_1,\\ldots,A_N) of length N. Find the value of the following expression:\n\\displaystyle \\sum_{i=1}^{N-1}\\sum_{j=i+1}^N (A_i \\oplus A_{i+1}\\oplus \\ldots \\oplus A_j).\n\nNotes on bitwise XOR\r\nThe bitwise XOR of non-negative integers A and B, denoted as A \\oplus B, is defined as follows:\r\n- In the binary representation of A \\oplus B, the digit at the 2^k (k \\geq 0) position is 1 if and only if exactly one of the digits at the 2^k position in the binary representations of A and B is 1; otherwise, it is 0.\r\nFor example, 3 \\oplus 5 = 6 (in binary: 011 \\oplus 101 = 110).\r\nIn general, the bitwise XOR of k integers p_1, \\dots, p_k is defined as (\\cdots ((p_1 \\oplus p_2) \\oplus p_3) \\oplus \\cdots \\oplus p_k).  It can be proved that this is independent of the order of p_1, \\dots, p_k.\n\nInput\n\nThe input is given from Standard Input in the following format:\nN \r\nA_1 A_2 \\ldots A_{N}\n\nOutput\n\nPrint the answer.\n\nConstraints\n\n\n- 2 \\leq N \\leq 2 \\times 10^5\n- 1 \\leq A_i \\leq 10^8\n- All input values are integers.\n\nSample Input 1\n\n3\r\n1 3 2\n\nSample Output 1\n\n3\r\n\nA_1 \\oplus A_2 = 2, A_1 \\oplus A_2 \\oplus A_3 = 0, and A_2 \\oplus A_3 = 1, so the answer is 2 + 0 + 1 = 3.\n\nSample Input 2\n\n7\r\n2 5 6 5 2 1 7\n\nSample Output 2\n\n83", "difficulty": "hard", "starter_code": "", "public_test_cases": "[{\"input\": \"3\\n1 3 2\\n\", \"output\": \"3\\n\", \"testtype\": \"stdin\"}, {\"input\": \"7\\n2 5 6 5 2 1 7\\n\", \"output\": \"83\\n\", \"testtype\": \"stdin\"}]"}
{"question_id": "3436", "question_title": "find-subarray-with-bitwise-or-closest-to-k", "question_content": "You are given an array nums and an integer k. You need to find a subarray of nums such that the absolute difference between k and the bitwise OR of the subarray elements is as small as possible. In other words, select a subarray nums[l..r] such that |k - (nums[l] OR nums[l + 1] ... OR nums[r])| is minimum.\nReturn the minimum possible value of the absolute difference.\nA subarray is a contiguous non-empty sequence of elements within an array.\n \nExample 1:\n\nInput: nums = [1,2,4,5], k = 3\nOutput: 0\nExplanation:\nThe subarray nums[0..1] has OR value 3, which gives the minimum absolute difference |3 - 3| = 0.\n\nExample 2:\n\nInput: nums = [1,3,1,3], k = 2\nOutput: 1\nExplanation:\nThe subarray nums[1..1] has OR value 3, which gives the minimum absolute difference |3 - 2| = 1.\n\nExample 3:\n\nInput: nums = [1], k = 10\nOutput: 9\nExplanation:\nThere is a single subarray with OR value 1, which gives the minimum absolute difference |10 - 1| = 9.\n\n \nConstraints:\n\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^9\n1 <= k <= 10^9", "difficulty": "hard", "starter_code": "class Solution:\n    def minimumDifference(self, nums: List[int], k: int) -> int:\n        ", "public_test_cases": "[{\"input\": \"[1, 2, 4, 5]\\n3\", \"output\": \"0\", \"testtype\": \"functional\"}, {\"input\": \"[1, 3, 1, 3]\\n2\", \"output\": \"1\", \"testtype\": \"functional\"}, {\"input\": \"[1]\\n10\", \"output\": \"9\", \"testtype\": \"functional\"}]"}
{"question_id": "3508", "question_title": "number-of-bit-changes-to-make-two-integers-equal", "question_content": "You are given two positive integers n and k.\nYou can choose any bit in the binary representation of n that is equal to 1 and change it to 0.\nReturn the number of changes needed to make n equal to k. If it is impossible, return -1.\n \nExample 1:\n\nInput: n = 13, k = 4\nOutput: 2\nExplanation:\nInitially, the binary representations of n and k are n = (1101)_2 and k = (0100)_2.\nWe can change the first and fourth bits of n. The resulting integer is n = (0100)_2 = k.\n\nExample 2:\n\nInput: n = 21, k = 21\nOutput: 0\nExplanation:\nn and k are already equal, so no changes are needed.\n\nExample 3:\n\nInput: n = 14, k = 13\nOutput: -1\nExplanation:\nIt is not possible to make n equal to k.\n\n \nConstraints:\n\n1 <= n, k <= 10^6", "difficulty": "easy", "starter_code": "class Solution:\n    def minChanges(self, n: int, k: int) -> int:\n        ", "public_test_cases": "[{\"input\": \"13\\n4\", \"output\": \"2\", \"testtype\": \"functional\"}, {\"input\": \"21\\n21\", \"output\": \"0\", \"testtype\": \"functional\"}, {\"input\": \"14\\n13\", \"output\": \"-1\", \"testtype\": \"functional\"}]"}
{"question_id": "3466", "question_title": "number-of-subarrays-with-and-value-of-k", "question_content": "Given an array of integers nums and an integer k, return the number of subarrays of nums where the bitwise AND of the elements of the subarray equals k.\n \nExample 1:\n\nInput: nums = [1,1,1], k = 1\nOutput: 6\nExplanation:\nAll subarrays contain only 1's.\n\nExample 2:\n\nInput: nums = [1,1,2], k = 1\nOutput: 3\nExplanation:\nSubarrays having an AND value of 1 are: [1,1,2], [1,1,2], [1,1,2].\n\nExample 3:\n\nInput: nums = [1,2,3], k = 2\nOutput: 2\nExplanation:\nSubarrays having an AND value of 2 are: [1,2,3], [1,2,3].\n\n \nConstraints:\n\n1 <= nums.length <= 10^5\n0 <= nums[i], k <= 10^9", "difficulty": "hard", "starter_code": "class Solution:\n    def countSubarrays(self, nums: List[int], k: int) -> int:\n        ", "public_test_cases": "[{\"input\": \"[1, 1, 1]\\n1\", \"output\": \"6\", \"testtype\": \"functional\"}, {\"input\": \"[1, 1, 2]\\n1\", \"output\": \"3\", \"testtype\": \"functional\"}, {\"input\": \"[1, 2, 3]\\n2\", \"output\": \"2\", \"testtype\": \"functional\"}]"}
{"question_id": "2730", "question_title": "maximum-or", "question_content": "You are given a 0-indexed integer array nums of length n and an integer k. In an operation, you can choose an element and multiply it by 2.\nReturn the maximum possible value of nums[0] | nums[1] | ... | nums[n - 1] that can be obtained after applying the operation on nums at most k times.\nNote that a | b denotes the bitwise or between two integers a and b.\n \nExample 1:\n\nInput: nums = [12,9], k = 1\nOutput: 30\nExplanation: If we apply the operation to index 1, our new array nums will be equal to [12,18]. Thus, we return the bitwise or of 12 and 18, which is 30.\n\nExample 2:\n\nInput: nums = [8,1,2], k = 2\nOutput: 35\nExplanation: If we apply the operation twice on index 0, we yield a new array of [32,1,2]. Thus, we return 32|1|2 = 35.\n\n \nConstraints:\n\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^9\n1 <= k <= 15", "difficulty": "medium", "starter_code": "class Solution:\n    def maximumOr(self, nums: List[int], k: int) -> int:\n        ", "public_test_cases": "[{\"input\": \"[12, 9]\\n1\", \"output\": \"30\", \"testtype\": \"functional\"}, {\"input\": \"[8, 1, 2]\\n2\", \"output\": \"35\", \"testtype\": \"functional\"}]"}
{"question_id": "2953", "question_title": "count-pairs-of-points-with-distance-k", "question_content": "You are given a 2D integer array coordinates and an integer k, where coordinates[i] = [x_i, y_i] are the coordinates of the i^th point in a 2D plane.\nWe define the distance between two points (x_1, y_1) and (x_2, y_2) as (x1 XOR x2) + (y1 XOR y2) where XOR is the bitwise XOR operation.\nReturn the number of pairs (i, j) such that i < j and the distance between points i and j is equal to k.\n \nExample 1:\n\nInput: coordinates = [[1,2],[4,2],[1,3],[5,2]], k = 5\nOutput: 2\nExplanation: We can choose the following pairs:\n- (0,1): Because we have (1 XOR 4) + (2 XOR 2) = 5.\n- (2,3): Because we have (1 XOR 5) + (3 XOR 2) = 5.\n\nExample 2:\n\nInput: coordinates = [[1,3],[1,3],[1,3],[1,3],[1,3]], k = 0\nOutput: 10\nExplanation: Any two chosen pairs will have a distance of 0. There are 10 ways to choose two pairs.\n\n \nConstraints:\n\n2 <= coordinates.length <= 50000\n0 <= x_i, y_i <= 10^6\n0 <= k <= 100", "difficulty": "medium", "starter_code": "class Solution:\n    def countPairs(self, coordinates: List[List[int]], k: int) -> int:\n        ", "public_test_cases": "[{\"input\": \"[[1, 2], [4, 2], [1, 3], [5, 2]]\\n5\", \"output\": \"2\", \"testtype\": \"functional\"}, {\"input\": \"[[1, 3], [1, 3], [1, 3], [1, 3], [1, 3]]\\n0\", \"output\": \"10\", \"testtype\": \"functional\"}]"}
{"question_id": "3093", "question_title": "sum-of-values-at-indices-with-k-set-bits", "question_content": "You are given a 0-indexed integer array nums and an integer k.\nReturn an integer that denotes the sum of elements in nums whose corresponding indices have exactly k set bits in their binary representation.\nThe set bits in an integer are the 1's present when it is written in binary.\n\nFor example, the binary representation of 21 is 10101, which has 3 set bits.\n\n \nExample 1:\n\nInput: nums = [5,10,1,5,2], k = 1\nOutput: 13\nExplanation: The binary representation of the indices are: \n0 = 000_2\n1 = 001_2\n2 = 010_2\n3 = 011_2\n4 = 100_2 \nIndices 1, 2, and 4 have k = 1 set bits in their binary representation.\nHence, the answer is nums[1] + nums[2] + nums[4] = 13.\nExample 2:\n\nInput: nums = [4,3,2,1], k = 2\nOutput: 1\nExplanation: The binary representation of the indices are:\n0 = 00_2\n1 = 01_2\n2 = 10_2\n3 = 11_2\nOnly index 3 has k = 2 set bits in its binary representation.\nHence, the answer is nums[3] = 1.\n\n \nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 10^5\n0 <= k <= 10", "difficulty": "easy", "starter_code": "class Solution:\n    def sumIndicesWithKSetBits(self, nums: List[int], k: int) -> int:\n        ", "public_test_cases": "[{\"input\": \"[5, 10, 1, 5, 2]\\n1\", \"output\": \"13\", \"testtype\": \"functional\"}, {\"input\": \"[4, 3, 2, 1]\\n2\", \"output\": \"1\", \"testtype\": \"functional\"}]"}
{"question_id": "3183", "question_title": "find-the-k-or-of-an-array", "question_content": "You are given a 0-indexed integer array nums, and an integer k.\nThe K-or of nums is a non-negative integer that satisfies the following:\n\nThe i^th bit is set in the K-or if and only if there are at least k elements of nums in which bit i is set.\n\nReturn the  K-or of nums.\nNote that a bit i is set in x if (2^i AND x) == 2^i, where AND is the bitwise AND operator.\n \nExample 1:\n\nInput: nums = [7,12,9,8,9,15], k = 4\nOutput: 9\nExplanation: Bit 0 is set at nums[0], nums[2], nums[4], and nums[5].\nBit 1 is set at nums[0], and nums[5].\nBit 2 is set at nums[0], nums[1], and nums[5].\nBit 3 is set at nums[1], nums[2], nums[3], nums[4], and nums[5].\nOnly bits 0 and 3 are set in at least k elements of the array, and bits i >= 4 are not set in any of the array's elements. Hence, the answer is 2^0 + 2^3 = 9.\n\nExample 2:\n\nInput: nums = [2,12,1,11,4,5], k = 6\nOutput: 0\nExplanation: Since k == 6 == nums.length, the 6-or of the array is equal to the bitwise AND of all its elements. Hence, the answer is 2 AND 12 AND 1 AND 11 AND 4 AND 5 = 0.\n\nExample 3:\n\nInput: nums = [10,8,5,9,11,6,8], k = 1\nOutput: 15\nExplanation: Since k == 1, the 1-or of the array is equal to the bitwise OR of all its elements. Hence, the answer is 10 OR 8 OR 5 OR 9 OR 11 OR 6 OR 8 = 15.\n\n \nConstraints:\n\n1 <= nums.length <= 50\n0 <= nums[i] < 2^31\n1 <= k <= nums.length", "difficulty": "easy", "starter_code": "class Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ", "public_test_cases": "[{\"input\": \"[7, 12, 9, 8, 9, 15]\\n4\", \"output\": \"9\", \"testtype\": \"functional\"}, {\"input\": \"[2, 12, 1, 11, 4, 5]\\n6\", \"output\": \"0\", \"testtype\": \"functional\"}, {\"input\": \"[10, 8, 5, 9, 11, 6, 8]\\n1\", \"output\": \"15\", \"testtype\": \"functional\"}]"}
{"question_id": "3193", "question_title": "maximum-strong-pair-xor-i", "question_content": "You are given a 0-indexed integer array nums. A pair of integers x and y is called a strong pair if it satisfies the condition:\n\n|x - y| <= min(x, y)\n\nYou need to select two integers from nums such that they form a strong pair and their bitwise XOR is the maximum among all strong pairs in the array.\nReturn the maximum XOR value out of all possible strong pairs in the array nums.\nNote that you can pick the same integer twice to form a pair.\n \nExample 1:\n\nInput: nums = [1,2,3,4,5]\nOutput: 7\nExplanation: There are 11 strong pairs in the array nums: (1, 1), (1, 2), (2, 2), (2, 3), (2, 4), (3, 3), (3, 4), (3, 5), (4, 4), (4, 5) and (5, 5).\nThe maximum XOR possible from these pairs is 3 XOR 4 = 7.\n\nExample 2:\n\nInput: nums = [10,100]\nOutput: 0\nExplanation: There are 2 strong pairs in the array nums: (10, 10) and (100, 100).\nThe maximum XOR possible from these pairs is 10 XOR 10 = 0 since the pair (100, 100) also gives 100 XOR 100 = 0.\n\nExample 3:\n\nInput: nums = [5,6,25,30]\nOutput: 7\nExplanation: There are 6 strong pairs in the array nums: (5, 5), (5, 6), (6, 6), (25, 25), (25, 30) and (30, 30).\nThe maximum XOR possible from these pairs is 25 XOR 30 = 7 since the only other non-zero XOR value is 5 XOR 6 = 3.\n\n \nConstraints:\n\n1 <= nums.length <= 50\n1 <= nums[i] <= 100", "difficulty": "easy", "starter_code": "class Solution:\n    def maximumStrongPairXor(self, nums: List[int]) -> int:\n        ", "public_test_cases": "[{\"input\": \"[1, 2, 3, 4, 5]\", \"output\": \"7\", \"testtype\": \"functional\"}, {\"input\": \"[10, 100]\", \"output\": \"0\", \"testtype\": \"functional\"}, {\"input\": \"[5, 6, 25, 30]\", \"output\": \"7\", \"testtype\": \"functional\"}]"}
{"question_id": "3246", "question_title": "check-if-bitwise-or-has-trailing-zeros", "question_content": "You are given an array of positive integers nums.\nYou have to check if it is possible to select two or more elements in the array such that the bitwise OR of the selected elements has at least one trailing zero in its binary representation.\nFor example, the binary representation of 5, which is \"101\", does not have any trailing zeros, whereas the binary representation of 4, which is \"100\", has two trailing zeros.\nReturn true if it is possible to select two or more elements whose bitwise OR has trailing zeros, return false otherwise.\n \nExample 1:\n\nInput: nums = [1,2,3,4,5]\nOutput: true\nExplanation: If we select the elements 2 and 4, their bitwise OR is 6, which has the binary representation \"110\" with one trailing zero.\n\nExample 2:\n\nInput: nums = [2,4,8,16]\nOutput: true\nExplanation: If we select the elements 2 and 4, their bitwise OR is 6, which has the binary representation \"110\" with one trailing zero.\nOther possible ways to select elements to have trailing zeroes in the binary representation of their bitwise OR are: (2, 8), (2, 16), (4, 8), (4, 16), (8, 16), (2, 4, 8), (2, 4, 16), (2, 8, 16), (4, 8, 16), and (2, 4, 8, 16).\n\nExample 3:\n\nInput: nums = [1,3,5,7,9]\nOutput: false\nExplanation: There is no possible way to select two or more elements to have trailing zeros in the binary representation of their bitwise OR.\n\n \nConstraints:\n\n2 <= nums.length <= 100\n1 <= nums[i] <= 100", "difficulty": "easy", "starter_code": "class Solution:\n    def hasTrailingZeros(self, nums: List[int]) -> bool:\n        ", "public_test_cases": "[{\"input\": \"[1, 2, 3, 4, 5]\", \"output\": \"true\", \"testtype\": \"functional\"}, {\"input\": \"[2, 4, 8, 16]\", \"output\": \"true\", \"testtype\": \"functional\"}, {\"input\": \"[1, 3, 5, 7, 9]\", \"output\": \"false\", \"testtype\": \"functional\"}]"}
{"question_id": "3249", "question_title": "minimum-number-of-operations-to-make-array-xor-equal-to-k", "question_content": "You are given a 0-indexed integer array nums and a positive integer k.\nYou can apply the following operation on the array any number of times:\n\nChoose any element of the array and flip a bit in its binary representation. Flipping a bit means changing a 0 to 1 or vice versa.\n\nReturn the minimum number of operations required to make the bitwise XOR of all elements of the final array equal to k.\nNote that you can flip leading zero bits in the binary representation of elements. For example, for the number (101)_2 you can flip the fourth bit and obtain (1101)_2.\n \nExample 1:\n\nInput: nums = [2,1,3,4], k = 1\nOutput: 2\nExplanation: We can do the following operations:\n- Choose element 2 which is 3 == (011)_2, we flip the first bit and we obtain (010)_2 == 2. nums becomes [2,1,2,4].\n- Choose element 0 which is 2 == (010)_2, we flip the third bit and we obtain (110)_2 = 6. nums becomes [6,1,2,4].\nThe XOR of elements of the final array is (6 XOR 1 XOR 2 XOR 4) == 1 == k.\nIt can be shown that we cannot make the XOR equal to k in less than 2 operations.\n\nExample 2:\n\nInput: nums = [2,0,2,0], k = 0\nOutput: 0\nExplanation: The XOR of elements of the array is (2 XOR 0 XOR 2 XOR 0) == 0 == k. So no operation is needed.\n\n \nConstraints:\n\n1 <= nums.length <= 10^5\n0 <= nums[i] <= 10^6\n0 <= k <= 10^6", "difficulty": "medium", "starter_code": "class Solution:\n    def minOperations(self, nums: List[int], k: int) -> int:\n        ", "public_test_cases": "[{\"input\": \"[2, 1, 3, 4]\\n1\", \"output\": \"2\", \"testtype\": \"functional\"}, {\"input\": \"[2, 0, 2, 0]\\n0\", \"output\": \"0\", \"testtype\": \"functional\"}]"}
{"question_id": "abc309_a", "question_title": "Nine", "question_content": "We have the following 3 \\times 3 board with integers from 1 through 9 written on it.\n\nYou are given two integers A and B between 1 and 9, where A < B.\nDetermine if the two squares with A and B written on them are adjacent horizontally.\n\nInput\n\nThe input is given from Standard Input in the following format:\nA B\n\nOutput\n\nPrint Yes if the two squares with A and B written on them are adjacent horizontally, and No otherwise.\n\nConstraints\n\n\n- 1 \\le A < B \\le 9\n- A and B are integers.\n\nSample Input 1\n\n7 8\n\nSample Output 1\n\nYes\r\n\nThe two squares with 7 and 8 written on them are adjacent horizontally, so print Yes.\n\nSample Input 2\n\n1 9\n\nSample Output 2\n\nNo\n\nSample Input 3\n\n3 4\n\nSample Output 3\n\nNo", "difficulty": "easy", "starter_code": "", "public_test_cases": "[{\"input\": \"7 8\\n\", \"output\": \"Yes\\n\", \"testtype\": \"stdin\"}, {\"input\": \"1 9\\n\", \"output\": \"No\\n\", \"testtype\": \"stdin\"}, {\"input\": \"3 4\\n\", \"output\": \"No\\n\", \"testtype\": \"stdin\"}]"}
{"question_id": "abc336_b", "question_title": "CTZ", "question_content": "For a positive integer X, let \\text{ctz}(X) be the (maximal) number of consecutive zeros at the end of the binary notation of X.\r\nIf the binary notation of X ends with a 1, then \\text{ctz}(X)=0.\nYou are given a positive integer N. Print \\text{ctz}(N).\n\nInput\n\nThe input is given from Standard Input in the following format:\nN\n\nOutput\n\nPrint \\text{ctz}(N).\n\nConstraints\n\n\n- 1\\leq N\\leq 10^9\n- N is an integer.\n\nSample Input 1\n\n2024\n\nSample Output 1\n\n3\r\n\n2024 is 11111101000 in binary, with three consecutive 0s from the end, so \\text{ctz}(2024)=3.\r\nThus, print 3.\n\nSample Input 2\n\n18\n\nSample Output 2\n\n1\r\n\n18 is 10010 in binary, so \\text{ctz}(18)=1.\r\nNote that we count the trailing zeros.\n\nSample Input 3\n\n5\n\nSample Output 3\n\n0", "difficulty": "easy", "starter_code": "", "public_test_cases": "[{\"input\": \"2024\\n\", \"output\": \"3\\n\", \"testtype\": \"stdin\"}, {\"input\": \"18\\n\", \"output\": \"1\\n\", \"testtype\": \"stdin\"}, {\"input\": \"5\\n\", \"output\": \"0\\n\", \"testtype\": \"stdin\"}]"}
{"question_id": "abc377_b", "question_title": "Avoid Rook Attack", "question_content": "There is a grid of 64 squares with 8 rows and 8 columns.\nLet (i,j) denote the square at the i-th row from the top (1\\leq i\\leq8) and j-th column from the left (1\\leq j\\leq8).\nEach square is either empty or has a piece placed on it.\nThe state of the squares is represented by a sequence (S_1,S_2,S_3,\\ldots,S_8) of 8 strings of length 8.\nSquare (i,j) (1\\leq i\\leq8,1\\leq j\\leq8) is empty if the j-th character of S_i is ., and has a piece if it is #.\nYou want to place your piece on an empty square in such a way that it cannot be captured by any of the existing pieces.\nA piece placed on square (i,j) can capture pieces that satisfy either of the following conditions:\n\n- Placed on a square in row i\n- Placed on a square in column j\n\nFor example, a piece placed on square (4,4) can capture pieces placed on the squares shown in blue in the following figure:\n\nHow many squares can you place your piece on?\n\nInput\n\nThe input is given from Standard Input in the following format:\nS_1\nS_2\nS_3\nS_4\nS_5\nS_6\nS_7\nS_8\n\nOutput\n\nPrint the number of empty squares where you can place your piece without it being captured by any existing pieces.\n\nConstraints\n\n\n- Each S_i is a string of length 8 consisting of . and # (1\\leq i\\leq 8).\n\nSample Input 1\n\n...#....\n#.......\n.......#\n....#...\n.#......\n........\n........\n..#.....\n\nSample Output 1\n\n4\n\nThe existing pieces can capture pieces placed on the squares shown in blue in the following figure:\n\nTherefore, you can place your piece without it being captured on 4 squares: square (6,6), square (6,7), square (7,6), and square (7,7).\n\nSample Input 2\n\n........\n........\n........\n........\n........\n........\n........\n........\n\nSample Output 2\n\n64\n\nThere may be no pieces on the grid.\n\nSample Input 3\n\n.#......\n..#..#..\n....#...\n........\n..#....#\n........\n...#....\n....#...\n\nSample Output 3\n\n4", "difficulty": "easy", "starter_code": "", "public_test_cases": "[{\"input\": \"...#....\\n#.......\\n.......#\\n....#...\\n.#......\\n........\\n........\\n..#.....\\n\", \"output\": \"4\\n\", \"testtype\": \"stdin\"}, {\"input\": \"........\\n........\\n........\\n........\\n........\\n........\\n........\\n........\\n\", \"output\": \"64\\n\", \"testtype\": \"stdin\"}, {\"input\": \".#......\\n..#..#..\\n....#...\\n........\\n..#....#\\n........\\n...#....\\n....#...\\n\", \"output\": \"4\\n\", \"testtype\": \"stdin\"}]"}
{"question_id": "3676", "question_title": "smallest-number-with-all-set-bits", "question_content": "You are given a positive number n.\nReturn the smallest number x greater than or equal to n, such that the binary representation of x contains only set bits\n \nExample 1:\n\nInput: n = 5\nOutput: 7\nExplanation:\nThe binary representation of 7 is \"111\".\n\nExample 2:\n\nInput: n = 10\nOutput: 15\nExplanation:\nThe binary representation of 15 is \"1111\".\n\nExample 3:\n\nInput: n = 3\nOutput: 3\nExplanation:\nThe binary representation of 3 is \"11\".\n\n \nConstraints:\n\n1 <= n <= 1000", "difficulty": "easy", "starter_code": "class Solution:\n    def smallestNumber(self, n: int) -> int:\n        ", "public_test_cases": "[{\"input\": \"5\", \"output\": \"7\", \"testtype\": \"functional\"}, {\"input\": \"10\", \"output\": \"15\", \"testtype\": \"functional\"}, {\"input\": \"3\", \"output\": \"3\", \"testtype\": \"functional\"}]"}
{"question_id": "3381", "question_title": "shortest-subarray-with-or-at-least-k-i", "question_content": "You are given an array nums of non-negative integers and an integer k.\nAn array is called special if the bitwise OR of all of its elements is at least k.\nReturn the length of the shortest special non-empty subarray of nums, or return -1 if no special subarray exists.\n \nExample 1:\n\nInput: nums = [1,2,3], k = 2\nOutput: 1\nExplanation:\nThe subarray [3] has OR value of 3. Hence, we return 1.\n\nExample 2:\n\nInput: nums = [2,1,8], k = 10\nOutput: 3\nExplanation:\nThe subarray [2,1,8] has OR value of 11. Hence, we return 3.\n\nExample 3:\n\nInput: nums = [1,2], k = 0\nOutput: 1\nExplanation:\nThe subarray [1] has OR value of 1. Hence, we return 1.\n\n \nConstraints:\n\n1 <= nums.length <= 50\n0 <= nums[i] <= 50\n0 <= k < 64", "difficulty": "easy", "starter_code": "class Solution:\n    def minimumSubarrayLength(self, nums: List[int], k: int) -> int:\n        ", "public_test_cases": "[{\"input\": \"[1, 2, 3]\\n2\", \"output\": \"1\", \"testtype\": \"functional\"}, {\"input\": \"[2, 1, 8]\\n10\", \"output\": \"3\", \"testtype\": \"functional\"}, {\"input\": \"[1, 2]\\n0\", \"output\": \"1\", \"testtype\": \"functional\"}]"}
{"question_id": "3428", "question_title": "find-the-xor-of-numbers-which-appear-twice", "question_content": "You are given an array nums, where each number in the array appears either once or twice.\nReturn the bitwise XOR of all the numbers that appear twice in the array, or 0 if no number appears twice.\n \nExample 1:\n\nInput: nums = [1,2,1,3]\nOutput: 1\nExplanation:\nThe only number that appears twice in nums is 1.\n\nExample 2:\n\nInput: nums = [1,2,3]\nOutput: 0\nExplanation:\nNo number appears twice in nums.\n\nExample 3:\n\nInput: nums = [1,2,2,1]\nOutput: 3\nExplanation:\nNumbers 1 and 2 appeared twice. 1 XOR 2 == 3.\n\n \nConstraints:\n\n1 <= nums.length <= 50\n1 <= nums[i] <= 50\nEach number in nums appears either once or twice.", "difficulty": "easy", "starter_code": "class Solution:\n    def duplicateNumbersXOR(self, nums: List[int]) -> int:\n        ", "public_test_cases": "[{\"input\": \"[1, 2, 1, 3]\", \"output\": \"1\", \"testtype\": \"functional\"}, {\"input\": \"[1, 2, 3]\", \"output\": \"0\", \"testtype\": \"functional\"}, {\"input\": \"[1, 2, 2, 1]\", \"output\": \"3\", \"testtype\": \"functional\"}]"}
{"question_id": "3567", "question_title": "convert-date-to-binary", "question_content": "You are given a string date representing a Gregorian calendar date in the yyyy-mm-dd format.\ndate can be written in its binary representation obtained by converting year, month, and day to their binary representations without any leading zeroes and writing them down in year-month-day format.\nReturn the binary representation of date.\n \nExample 1:\n\nInput: date = \"2080-02-29\"\nOutput: \"100000100000-10-11101\"\nExplanation:\n100000100000, 10, and 11101 are the binary representations of 2080, 02, and 29 respectively.\n\nExample 2:\n\nInput: date = \"1900-01-01\"\nOutput: \"11101101100-1-1\"\nExplanation:\n11101101100, 1, and 1 are the binary representations of 1900, 1, and 1 respectively.\n\n \nConstraints:\n\ndate.length == 10\ndate[4] == date[7] == '-', and all other date[i]'s are digits.\nThe input is generated such that date represents a valid Gregorian calendar date between Jan 1^st, 1900 and Dec 31^st, 2100 (both inclusive).", "difficulty": "easy", "starter_code": "class Solution:\n    def convertDateToBinary(self, date: str) -> str:\n        ", "public_test_cases": "[{\"input\": \"\\\"2080-02-29\\\"\", \"output\": \"\\\"100000100000-10-11101\\\"\", \"testtype\": \"functional\"}, {\"input\": \"\\\"1900-01-01\\\"\", \"output\": \"\\\"11101101100-1-1\\\"\", \"testtype\": \"functional\"}]"}
